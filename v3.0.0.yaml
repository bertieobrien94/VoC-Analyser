openapi: 3.1.0
info:
  title: VoC-Analyser API (v3.0 schema)
  version: 3.0.0
  description: >
    OpenAPI for Feedback Items and Terms (single hierarchical taxonomy table).
    Aligns with v3.0 instructions: Type enum, Term_ID, Mapping_Level, Mapping_Confidence,
    canonicalization via Canonical_ID, and bulk remap by Term.
servers:
  - url: https://api.sheetbest.com
security:
  - sheetbestApiKey: []

components:
  securitySchemes:
    sheetbestApiKey:
      type: apiKey
      in: header
      name: X-Api-Key

  parameters:
    TermIdParam:
      name: Term_ID
      in: path
      required: true
      description: Primary key of a Term row
      schema: { type: string }
    FeedbackIdParam:
      name: Feedback_ID
      in: path
      required: true
      description: Primary key of a Feedback row
      schema: { type: string }

  schemas:
    FeedbackItem:
      type: object
      description: Canonical structured feedback row (v3.0)
      required:
        - Feedback_ID
        - Summary
        - Quote
        - Person
        - Timestamp
        - Type
        - Created_By
        - Created_At
        - Updated_At
      properties:
        Feedback_ID: { type: string, description: "Stable ID, like fb_000072" }
        Summary:     { type: string, description: "LLM-generated (3–10 words)" }
        Quote:       { type: string, description: "Verbatim customer excerpt" }
        Person:      { type: string, description: "Name or 'Unknown'" }
        Timestamp:   { type: string, description: "ISO-8601 or 'Unknown'" }
        Type:
          type: string
          description: "Feedback classification (see instructions Step 2a)"
          enum: ["Positive feedback","Change request","Needs clarification","Market insight","Opportunity"]
        Term_ID:
          type: string
          nullable: true
          description: "FK to Terms (Status=Active)."
        Source_Type:
          type: string
          enum: ["Email","Transcript","Message","Support ticket","RFI/RFP","Unknown"]
        Source_Ref:  { type: string, nullable: true, description: "URL/transcript/file ref" }
        Mapping_Level:
          type: integer
          enum: [1,2,3]
          description: "1=Category, 2=Subcategory, 3=Subject"
        Mapping_Confidence:
          type: number
          minimum: 0
          maximum: 1
          description: "Confidence for the assigned Term"
        Created_By:  { type: string }
        Created_At:  { type: string, format: date-time }
        Updated_At:  { type: string, format: date-time }
      x-validationRules:
        - name: feedback_term_id_must_exist
          summary: "When Term_ID is supplied, it must reference an existing Term row."
          expression: "Term_ID is null or term exists"
        - name: feedback_term_must_resolve_to_active
          summary: "Reject Draft Terms. Deprecated Terms remap to Canonical_ID when present; otherwise reject the write."
          expression: "Term_ID is null or term.Status = 'Active' or (term.Status = 'Deprecated' and term.Canonical_ID is not null)"
        - name: feedback_Mapping_Level_must_match_term_level
          summary: "If Term_ID is provided, Mapping_Level must match the referenced Term's Level."
          expression: "Term_ID is null or (Mapping_Level is not null and Mapping_Level = term.Level)"
          status: 409
          hint: "Set Mapping_Level to the selected Term's Level."
      x-writeTransforms:
        - name: remap_feedback_term_to_canonical
          summary: "If a deprecated Term with a Canonical_ID is provided, automatically replace Term_ID with the canonical value before persisting."
          when: "term.Status = 'Deprecated' and term.Canonical_ID is not null"
          set:
            Term_ID: "term.Canonical_ID"

    FeedbackItemUpdate:
      type: object
      description: Partial update for a Feedback row; include only fields you want to change.
      minProperties: 1
      additionalProperties: false
      properties:
        Type:
          type: string
          description: "Feedback classification (see instructions Step 2a)"
          enum: ["Positive feedback","Change request","Needs clarification","Market insight","Opportunity"]
        Term_ID:
          type: string
          nullable: true
          description: "FK to Terms (Status=Active)."
        Mapping_Level:
          type: integer
          enum: [1,2,3]
          description: "1=Category, 2=Subcategory, 3=Subject"
        Mapping_Confidence:
          type: number
          minimum: 0
          maximum: 1
          description: "Confidence for the assigned Term"
        Updated_At:  { type: string, format: date-time }
      x-validationRules:
        - name: feedback_update_term_id_must_exist
          summary: "If Term_ID is included in the update payload, it must reference an existing Term row."
          expression: "Term_ID is null or term exists"
        - name: feedback_update_term_must_resolve_to_active
          summary: "Reject Draft Terms. Deprecated Terms remap to Canonical_ID when present; otherwise reject the write."
          expression: "Term_ID is null or term.Status = 'Active' or (term.Status = 'Deprecated' and term.Canonical_ID is not null)"
        - name: feedback_update_Mapping_Level_must_match_term_level
          summary: "If Term_ID is provided, Mapping_Level must match the referenced Term's Level."
          expression: "Term_ID is null or (Mapping_Level is not null and Mapping_Level = term.Level)"
          status: 409
          hint: "Set Mapping_Level to the selected Term's Level."
      x-writeTransforms:
        - name: remap_feedback_update_term_to_canonical
          summary: "When Term_ID references a deprecated Term with Canonical_ID, automatically set Term_ID to the canonical value before persisting."
          when: "term.Status = 'Deprecated' and term.Canonical_ID is not null"
          set:
            Term_ID: "term.Canonical_ID"

    Term:
      type: object
      description: Single-table hierarchical taxonomy term (v3.0)
      required: [ Term_ID, Term, Level, Status, Created_By, Created_At, Updated_At ]
      properties:
        Term_ID:     { type: string, description: "Stable unique ID, e.g., tx_0001" }
        Term:        { type: string, description: "Display name (localizable)" }
        Slug:        { type: string, description: "URL-safe identifier", nullable: true }
        Level:
          type: integer
          enum: [1,2,3]
          description: "1=Category, 2=Subcategory, 3=Subject"
        Definition:  { type: string, nullable: true }
        Synonyms:    { type: string, nullable: true, description: "Semicolon-separated list" }
        Status:
          type: string
          enum: [Active, Deprecated, Draft]
        Parent_ID:    { type: string, nullable: true, description: "NULL for Level=1; Level 2→L1; Level 3→L2" }
        Canonical_ID: { type: string, nullable: true, description: "Active replacement for Deprecated terms (must differ from Term_ID)" }
        Ordinal:     { type: integer, minimum: 0, nullable: true }
        Depth:       { type: integer, nullable: true }
        Path_IDs:    { type: string, nullable: true }
        Path_Slugs:  { type: string, nullable: true }
        Notes:       { type: string, nullable: true }
        Created_By:  { type: string }
        Created_At:  { type: string, format: date-time }
        Updated_At:  { type: string, format: date-time }
      allOf:
        - if:
            properties:
              Level: { const: 1 }
            required: [Level]
          then:
            required: [Parent_ID]
            properties:
              Parent_ID: { const: null }
        - if:
            properties:
              Level: { const: 2 }
            required: [Level]
          then:
            required: [Parent_ID]
            properties:
              Parent_ID:
                type: string
                nullable: false
        - if:
            properties:
              Level: { const: 3 }
            required: [Level]
          then:
            required: [Parent_ID]
            properties:
              Parent_ID:
                type: string
                nullable: false
        - if:
            properties:
              Status: { const: Deprecated }
            required: [Status]
          then:
            required: [Canonical_ID]
            properties:
              Canonical_ID:
                type: string
                nullable: false
      x-validationRules:
        - name: level_parent_consistency
          summary: "Level 2 Terms require a Level 1 parent; Level 3 Terms require a Level 2 parent."
          expression: "(Level != 2 or parent.Level = 1) and (Level != 3 or parent.Level = 2)"
        - name: deprecated_terms_require_distinct_canonical
          summary: "Deprecated Terms must reference a different Canonical_ID."
          expression: "Status != 'Deprecated' or (Canonical_ID is not null and Canonical_ID <> Term_ID)"

    TermUpdate:
      type: object
      description: Partial update for a Term row; include only fields you want to change.
      minProperties: 1
      additionalProperties: false
      properties:
        Term:        { type: string, description: "Display name (localizable)" }
        Slug:        { type: string, nullable: true, description: "URL-safe identifier" }
        Level:
          type: integer
          enum: [1,2,3]
          description: "1=Category, 2=Subcategory, 3=Subject"
        Definition:  { type: string, nullable: true }
        Synonyms:    { type: string, nullable: true, description: "Semicolon-separated list" }
        Status:
          type: string
          enum: [Active, Deprecated, Draft]
        Parent_ID:    { type: string, nullable: true, description: "NULL for Level=1; Level 2→L1; Level 3→L2" }
        Canonical_ID: { type: string, nullable: true, description: "Active replacement for Deprecated terms (must differ from Term_ID)" }
        Ordinal:     { type: integer, minimum: 0, nullable: true }
        Depth:       { type: integer, nullable: true }
        Path_IDs:    { type: string, nullable: true }
        Path_Slugs:  { type: string, nullable: true }
        Notes:       { type: string, nullable: true }
        Created_By:  { type: string }
        Created_At:  { type: string, format: date-time }
        Updated_At:  { type: string, format: date-time }
      allOf:
        - if:
            properties:
              Level: { const: 1 }
            required: [Level]
          then:
            required: [Parent_ID]
            properties:
              Parent_ID: { const: null }
        - if:
            properties:
              Level: { const: 2 }
            required: [Level]
          then:
            required: [Parent_ID]
            properties:
              Parent_ID:
                type: string
                nullable: false
        - if:
            properties:
              Level: { const: 3 }
            required: [Level]
          then:
            required: [Parent_ID]
            properties:
              Parent_ID:
                type: string
                nullable: false
        - if:
            properties:
              Status: { const: Deprecated }
            required: [Status]
          then:
            required: [Canonical_ID]
            properties:
              Canonical_ID:
                type: string
                nullable: false
      x-validationRules:
        - name: update_level_parent_consistency
          summary: "When updating Level to 2 or 3, include the correct parent Term reference."
          expression: "(Level != 2 or Parent_ID is not null) and (Level != 3 or Parent_ID is not null)"
        - name: update_deprecated_terms_require_distinct_canonical
          summary: "Status=Deprecated updates must supply a Canonical_ID different from Term_ID."
          expression: "Status != 'Deprecated' or (Canonical_ID is not null and Canonical_ID <> Term_ID)"

paths:

  ############################
  # TERMS (taxonomy v3.0)
  ############################
  
  /sheets/895dac3e-2ad5-4f1a-96e7-ae12687b0cfa:
    get:
      operationId: listTerms
      summary: List Terms
      description: List Terms with optional client-side filtering.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items: { $ref: '#/components/schemas/Term' }
    post:
      operationId: createTerm
      summary: Create Term
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/Term' }
      responses:
        '201': { description: Created }

  /sheets/895dac3e-2ad5-4f1a-96e7-ae12687b0cfa/Term_ID/{Term_ID}:
    patch:
      operationId: updateTerm
      summary: Update Term by Term_ID
      parameters:
        - name: Term_ID
          in: path
          required: true
          description: Primary key of a Term row
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/TermUpdate' }
      responses:
        '200': { description: Updated }
 
  ##################################
  # FEEDBACK ITEMS (v3.0 schema)
  ##################################
 
  /sheets/e1b92735-b604-4564-a285-c0e5c2614cb0:
    get:
      operationId: listFeedbackItems
      summary: List Feedback Items
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items: { $ref: '#/components/schemas/FeedbackItem' }

    post:
      operationId: createFeedbackItem
      summary: Create Feedback Item
      description: >
        Create a new Feedback Item. The server enforces idempotency by calculating
        `sha256(Quote|Person|Timestamp|Term_ID)` and, when a collision occurs,
        applies the payload as an update to the existing record (behaving like a
        PATCH) and returns `200 OK` instead of `201 Created`.
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/FeedbackItem' }
      responses:
        '201':
          description: Created
          content:
            application/json:
              schema: { $ref: '#/components/schemas/FeedbackItem' }
        '200':
          description: Updated existing Feedback Item via idempotency hash collision
          content:
            application/json:
              schema: { $ref: '#/components/schemas/FeedbackItem' }

  /sheets/e1b92735-b604-4564-a285-c0e5c2614cb0/bulk:
    post:
      operationId: bulkCreateFeedbackItems
      summary: Bulk create Feedback Items
      description: >
        Insert multiple Feedback Items in one request. Each element of the array is
        processed using the same idempotency hash logic as `createFeedbackItem`, so
        duplicates are updated instead of inserted.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: array
              minItems: 1
              items: { $ref: '#/components/schemas/FeedbackItem' }
      responses:
        '201':
          description: Created rows
          content:
            application/json:
              schema:
                type: array
                items: { $ref: '#/components/schemas/FeedbackItem' }
        '200':
          description: Existing rows updated via idempotency hash collision
          content:
            application/json:
              schema:
                type: array
                items: { $ref: '#/components/schemas/FeedbackItem' }

  /sheets/e1b92735-b604-4564-a285-c0e5c2614cb0/Feedback_ID/{Feedback_ID}:
    patch:
      operationId: updateFeedbackItem
      summary: Update Feedback Item by Feedback_ID
      parameters:
        - in: path
          name: Feedback_ID
          required: true
          description: Primary key of a Feedback row
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/FeedbackItemUpdate' }
      responses:
        '200': { description: Updated }
 
  ###################################################
  # BULK REMAP: FeedbackItems by (old) Term_ID → new
  ###################################################
  /sheets/e1b92735-b604-4564-a285-c0e5c2614cb0/Term_ID/{Term_ID}:
    patch:
      operationId: bulkRemapFeedbackItemsByTerm
      summary: Bulk update FeedbackItems where Term_ID == old Term_ID
      description: >
        Use for canonicalization: remap all FeedbackItems from a deprecated Term to its Canonical_ID.
      parameters:
        - in: path
          name: Term_ID
          required: true
          description: Primary key of a Term row
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [ Canonical_Term_ID, Updated_At ]
              properties:
                Canonical_Term_ID:
                  type: string
                  description: "The *new* canonical Term_ID to set on matching FeedbackItems"
                Updated_At:
                  type: string
                  format: date-time
      responses:
        '200': { description: Bulk Updated }
